#!/usr/bin/env python3
"""Aggregate force, stiffness (Eq.16 normalized), and EMG per finger across all success demonstrations.

Input: directory with normalized global T_K CSVs (generated by generate_stiffness_profiles_global_tk_normalized.py after patch adding EMG columns).
Output:
  - CSV: force_stiffness_emg_aggregated.csv (row-wise per timestamp with per-finger metrics)
  - JSON: force_stiffness_emg_summary.json (stats + correlations)
  - PNGs: per finger histogram & scatter plots

Stats per finger:
  force_norm: L2 norm of (s*_fx, s*_fy, s*_fz)
  k_norm: L2 norm of (finger_k1, k2, k3)
  Pearson/Spearman(force_norm, k_norm)
  Per-EMG-channel Pearson/Spearman(emg_chX, k_norm)

"""
from __future__ import annotations
import argparse, json
from pathlib import Path
from typing import Dict, List
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

FINGER_MAP = {'th':'s1', 'if':'s2', 'mf':'s3'}
EMG_CHANNELS = [f'emg_ch{i}' for i in range(1,9)]

def l2norm(a: np.ndarray, axis: int = 1) -> np.ndarray:
    return np.sqrt(np.sum(a**2, axis=axis))

def corr_pearson(x: np.ndarray, y: np.ndarray) -> float:
    if x.size == 0 or y.size == 0:
        return float('nan')
    xv = x - x.mean()
    yv = y - y.mean()
    denom = np.sqrt((xv**2).sum()) * np.sqrt((yv**2).sum())
    if denom < 1e-12:
        return float('nan')
    return float((xv * yv).sum() / denom)

def corr_spearman(x: np.ndarray, y: np.ndarray) -> float:
    rx = np.argsort(np.argsort(x))
    ry = np.argsort(np.argsort(y))
    return corr_pearson(rx.astype(float), ry.astype(float))

def aggregate(input_dir: Path, out_dir: Path) -> None:
    csvs = sorted([p for p in input_dir.glob('*.csv') if p.is_file()])
    if not csvs:
        raise SystemExit('No CSV files found in input directory')
    rows: List[Dict[str, float]] = []

    per_finger_force: Dict[str, List[np.ndarray]] = {f: [] for f in FINGER_MAP}
    per_finger_k: Dict[str, List[np.ndarray]] = {f: [] for f in FINGER_MAP}
    per_finger_emg: Dict[str, Dict[str, List[np.ndarray]]] = {f: {ch: [] for ch in EMG_CHANNELS} for f in FINGER_MAP}

    for fp in csvs:
        try:
            df = pd.read_csv(fp)
        except Exception as exc:
            print(f'[skip] {fp.name}: load failed ({exc})')
            continue
        time = df['time_s'].to_numpy(dtype=float) if 'time_s' in df else np.arange(len(df), dtype=float)
        for finger, sensor in FINGER_MAP.items():
            force_cols = [f'{sensor}_fx', f'{sensor}_fy', f'{sensor}_fz']
            k_cols = [f'{finger}_k1', f'{finger}_k2', f'{finger}_k3']
            if not all(c in df.columns for c in force_cols + k_cols):
                continue
            forces = df[force_cols].to_numpy(dtype=float)
            k_comp = df[k_cols].to_numpy(dtype=float)
            fnorm = l2norm(forces)
            knorm = l2norm(k_comp)
            per_finger_force[finger].append(fnorm)
            per_finger_k[finger].append(knorm)
            # collect emg per channel if available
            for ch in EMG_CHANNELS:
                if ch in df.columns:
                    per_finger_emg[finger][ch].append(df[ch].to_numpy(dtype=float))
            # row-wise export (one row per timestamp per finger)
            for t, fval, kval in zip(time, fnorm, knorm):
                rows.append({
                    'file_id': fp.stem,
                    'time_s': float(t),
                    'finger': finger,
                    'force_norm': float(fval),
                    'k_norm': float(kval)
                })

    agg_df = pd.DataFrame(rows)
    out_dir.mkdir(parents=True, exist_ok=True)
    agg_csv = out_dir / 'force_stiffness_emg_aggregated.csv'
    agg_df.to_csv(agg_csv, index=False)

    summary = {'fingers': {}, 'files_processed': len(csvs), 'rows': len(agg_df)}
    for finger in FINGER_MAP.keys():
        if not per_finger_force[finger]:
            continue
        f_all = np.concatenate(per_finger_force[finger])
        k_all = np.concatenate(per_finger_k[finger])
        finger_entry = {
            'force_norm': {'min': float(f_all.min()), 'max': float(f_all.max()), 'mean': float(f_all.mean()), 'std': float(f_all.std())},
            'k_norm': {'min': float(k_all.min()), 'max': float(k_all.max()), 'mean': float(k_all.mean()), 'std': float(k_all.std())},
            'force_k_corr': {
                'pearson': corr_pearson(f_all, k_all),
                'spearman': corr_spearman(f_all, k_all)
            },
            'emg_channel_corr': {}
        }
        for ch in EMG_CHANNELS:
            series_list = per_finger_emg[finger][ch]
            if not series_list:
                continue
            emg_all = np.concatenate(series_list)
            finger_entry['emg_channel_corr'][ch] = {
                'pearson': corr_pearson(emg_all, k_all),
                'spearman': corr_spearman(emg_all, k_all)
            }
        summary['fingers'][finger] = finger_entry

    summary_json = out_dir / 'force_stiffness_emg_summary.json'
    with open(summary_json, 'w') as f:
        json.dump(summary, f, indent=2)

    # Plots per finger
    for finger in summary['fingers']:
        f_all = np.concatenate(per_finger_force[finger])
        k_all = np.concatenate(per_finger_k[finger])
        fig, axes = plt.subplots(1, 3, figsize=(12,4))
        axes[0].hist(f_all, bins=50, color='#1f77b4', alpha=0.8)
        axes[0].set_title(f'{finger} force_norm')
        axes[1].hist(k_all, bins=50, color='#ff7f0e', alpha=0.8)
        axes[1].set_title(f'{finger} k_norm')
        axes[2].scatter(f_all, k_all, s=4, alpha=0.3)
        axes[2].set_xlabel('force_norm')
        axes[2].set_ylabel('k_norm')
        axes[2].set_title(f'{finger} force vs k_norm')
        fig.tight_layout()
        fig.savefig(out_dir / f'{finger}_force_k_scatter.png', dpi=140)
        plt.close(fig)

    # (NEW) Combined multi-finger scatter & distributions
    try:
        fig, axes = plt.subplots(2, 3, figsize=(14,8))
        for col,finger in enumerate(['th','if','mf']):
            if not per_finger_force[finger]:
                continue
            f_all = np.concatenate(per_finger_force[finger])
            k_all = np.concatenate(per_finger_k[finger])
            # top row: scatter force vs k
            ax_scatter = axes[0, col]
            ax_scatter.scatter(f_all, k_all, s=3, alpha=0.25)
            ax_scatter.set_title(f'{finger} force vs k (Pearson {summary["fingers"][finger]["force_k_corr"]["pearson"]:.2f})')
            ax_scatter.set_xlabel('force_norm')
            ax_scatter.set_ylabel('k_norm')
            # bottom row: k histogram
            ax_hist = axes[1, col]
            ax_hist.hist(k_all, bins=60, color='#ff7f0e', alpha=0.8)
            ax_hist.set_title(f'{finger} k_norm dist')
            ax_hist.set_xlabel('k_norm')
        fig.tight_layout()
        fig.savefig(out_dir / 'all_fingers_force_k_summary.png', dpi=160)
        plt.close(fig)
    except Exception as exc:
        print('[warn] combined figure failed:', exc)

    print('[ok] Aggregation complete')
    print(' CSV :', agg_csv)
    print(' JSON:', summary_json)

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--input-dir', type=Path, required=True, help='Directory with normalized stiffness CSVs (with EMG columns)')
    ap.add_argument('--out-dir', type=Path, required=True, help='Output directory for aggregated results')
    args = ap.parse_args()
    aggregate(args.input_dir, args.out_dir)

if __name__ == '__main__':
    main()
